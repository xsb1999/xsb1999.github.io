<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Andy Xu&#39;s Blog</title>
  
  
  <link href="http://blog.andy.fit/atom.xml" rel="self"/>
  
  <link href="http://blog.andy.fit/"/>
  <updated>2021-11-15T05:36:59.760Z</updated>
  <id>http://blog.andy.fit/</id>
  
  <author>
    <name>Andy Xu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「PSO」Algorithm improvement</title>
    <link href="http://blog.andy.fit/2021/11/15/PSO/"/>
    <id>http://blog.andy.fit/2021/11/15/PSO/</id>
    <published>2021-11-15T03:08:51.000Z</published>
    <updated>2021-11-15T05:36:59.760Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/TBM/1.gif" alt="TBM1" style="zoom: 150%;" /><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Particle swarm optimization (PSO: Particle swarm optimization) is an evolutionary computation technology. Originated from the study of bird predation behavior. The basic idea of particle swarm optimization algorithm is to find the optimal solution through collaboration and information sharing between individuals in the group. It is simple and easy to implement and does not have many parameter adjustments. It has been widely used in the application fields of function optimization, neural network training, fuzzy system control and other genetic algorithms.</p><p>The particle swarm algorithm simulates the birds in a flock of birds by designing a massless particle. The particle has only two attributes: speed and position. Speed represents the speed of movement, and position represents the direction of movement. Each particle searches for the optimal solution individually in the search space, and records it as the current individual extreme value, and shares the individual extreme value with other particles in the entire particle swarm, and finds the optimal individual extreme value as the entire particle The current global optimal solution of the swarm, all particles in the particle swarm adjust their speed and position according to the current individual extreme value they find and the current global optimal solution shared by the entire particle swarm. </p><h2 id="Improvements"><a href="#Improvements" class="headerlink" title="Improvements"></a>Improvements</h2><p><strong>I made two versions of improvements to the traditional PSO</strong></p><h4 id="1-Improvement-purpose"><a href="#1-Improvement-purpose" class="headerlink" title="1. Improvement purpose"></a>1. Improvement purpose</h4><p><em><strong>1) PSO0 —&gt; PSO1</strong></em></p><p><img src="../images/PSO/001.png" alt="img"></p><p>In PSO0, w is a constant, in PSO1, w satisfies the upper formula</p><p>The larger w is, the faster the particle moves, and the larger the span of each movement. Therefore, an appropriate increase in w will shorten the optimization time. But a large w will also bring about problems, that is, the particles may skip the extreme points directly and fail to find the optimal solution.</p><p>Therefore, the particles are classified according to whether the current fitness value is greater than the average fitness value. If the fitness value of the particle is greater than the average value, it means that the particle is still far away from the optimal position. Therefore, we need to make w larger and take ω_max.If less than or equal to the mean, then use <img src="../images/PSO/000.png" alt="img"> </p><p>First of all, because the fitness value of the particle is less than the average value at this time, it means that it is relatively close to the optimal position, so w should be smaller to prevent the particle from skipping the optimal position if w is too large. But this time will bring another problem: falling into a local optimal solution. To solve this problem, I use To solve this problem, I used <img src="../images/PSO/002.png" alt="img"> to constrain the value of ω.</p><p>When the value is large, it means that the average value is very close to the minimum value, that is, the particles are close together and gather at one point. This is likely to be the local optimal solution, so increase w to jump out of this local optimal position. But we can’t make w too large, so we use ω_min to add a part here, which is similar to a penalty factor.</p><p><em><strong>2) PSO1 —&gt; PSO2</strong></em></p><p><img src="../images/PSO/003.png" alt="img"></p><p>In PSO2, I made the following changes to PSO1</p><p><strong>1) Change ω_min to ω_max</strong></p><p>Because in the actual test, it is found that if ω_min is taken, the iteration speed is very slow and often because the value of w is not large enough, it is impossible to jump out of the local optimal position. Therefore, change it to ω_max here, so that w is large enough to speed up the convergence speed and make the particles better jump out of the local optimal position.</p><p><strong>2) Change the product term</strong></p><p>original:  <img src="../images/PSO/004.png" alt="img"></p><p>current: <img src="../images/PSO/005.png" alt="img"> </p><p>When the fitness value of the current particle is close to the average fitness value of all particles, and the average fitness value is very close to the minimum value, it means that all the particles are gathered in one position, and this position may be the local optimal position, so To make w larger, that is, reduce it.</p><p>For the constant of 500, it is an empirical value obtained by me after testing, and it has no practical meaning.</p><h4 id="2-Specific-methods"><a href="#2-Specific-methods" class="headerlink" title="2. Specific methods"></a>2. Specific methods</h4><p><strong>PSO speed and position update formula:</strong></p><p><img src="../images/PSO/009.png" alt="img"> </p><p><img src="../images/PSO/010.png" alt="img"> </p><p><strong>PSO1 inertia weight w update formula:</strong></p><p><img src="../images/PSO/001.png" alt="img"></p><p><strong>PSO2 inertia weight w update formula:</strong></p><p><img src="../images/PSO/003.png" alt="img"></p><p><strong>Flow chart:</strong></p><img src="../images/PSO/008.png" alt="img" style="zoom: 80%;" /><h4 id="3-Improved-effect"><a href="#3-Improved-effect" class="headerlink" title="3. Improved effect"></a>3. Improved effect</h4><p><img src="../images/PSO/LGB.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/images/TBM/1.gif&quot; alt=&quot;TBM1&quot; style=&quot;zoom: 150%;&quot; /&gt;

&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Intr</summary>
      
    
    
    
    
    <category term="algorithm" scheme="http://blog.andy.fit/tags/algorithm/"/>
    
    <category term="Swarm intelligence" scheme="http://blog.andy.fit/tags/Swarm-intelligence/"/>
    
    <category term="Python" scheme="http://blog.andy.fit/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>「TBM」Intelligent Perception System</title>
    <link href="http://blog.andy.fit/2021/11/14/TBM/"/>
    <id>http://blog.andy.fit/2021/11/14/TBM/</id>
    <published>2021-11-14T13:48:47.000Z</published>
    <updated>2021-11-15T05:21:12.341Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/TBM/TBM1.png" alt="TBM1"></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This project is based on the real-time rock-machine interaction data generated by Jilin Yinsong TBM (Tunnel Boring Machine) excavation in the tunnel. The machine learning method is used to detect the danger of the road section ahead during the TBM tunneling, that is, to determine whether there is a collapse or fault in the road section ahead. And remind the driver in time. In the end, our team is committed to developing a system that can accurately control the real-time parameters and road conditions of the TBM during tunnel excavation. The system mainly has three modules: advance prediction of landslides, advance prediction of faults, and real-time data prediction.</p><h2 id="Research-task"><a href="#Research-task" class="headerlink" title="Research task"></a>Research task</h2><h4 id="1-Data-preprocessing"><a href="#1-Data-preprocessing" class="headerlink" title="1. Data preprocessing"></a>1. Data preprocessing</h4><p>Use libraries such as numpy and pandas in Python to process the initial data, including modifying the data format, data partitioning, merging, removing outliers and interpolation, etc.</p><h4 id="2-Three-stage-division-normal-early-warning-landslide"><a href="#2-Three-stage-division-normal-early-warning-landslide" class="headerlink" title="2. Three-stage division (normal, early warning, landslide)"></a>2. Three-stage division (normal, early warning, landslide)</h4><p>According to the changes of various rock-machine interaction parameters before the collapse of the TBM during the tunneling process, the tunneling process can be divided into three stages: the normal section, the early warning section, and the collapse section. Among them, the normal section is defined as the normal tunneling section, that is, the tunneling section outside the impact range of the front collapse. During the tunneling process, the TBM machine parameters do not respond to the collapse; the early warning section refers to the area within the impact range of the front collapse. In the tunneling section before the location, the TBM machine parameters will respond to the collapse in this section of the tunneling process; the collapsed section refers to the section where the TBM is tunneling at the location of the collapse.</p><p>The significance of the early warning section is to realize the advance prediction of the landslide. In the process of TBM tunnelling, it is meaningless to predict whether there will be a landslide at the current moment. It is worthy of our study to make an early warning of the landslide ahead. Therefore, I need to mark an early warning segment for these data, so that the data is of three types. What I have to do is to predict whether the current TBM tunneling is an early warning section (essentially a 3-classification problem), and if it is, an alarm will be issued immediately, indicating that there is a possibility of a landslide ahead.</p><p>The problem now is that from the existing data, I can obtain the data of the normal section and the landslide section, but cannot get the data of the early warning section. Therefore, I need to artificially formulate a rule according to the change law of different rock-machine interaction parameters near the landslide. To divide the early warning section.</p><p>The early warning segment is divided by analyzing the rock-machine interaction parameters of TBM before the collapse. Among them, the “cutterhead torque” has the most significant response to the collapse. The cutter head torque will increase sharply before the collapse, and suddenly drop sharply when the torque increases to the maximum value. Therefore, I choose to divide the pre-warning segment with the maximum torque point as the limit, and set the descending segment of the cutter head torque before the collapse area as the pre-warning area (as shown in the figure below).</p><img src="/images/TBM/TBM3.png" alt="TBM1" style="zoom:75%;" /><h4 id="3-Feature-selection-amp-Interpretation-with-SHAP"><a href="#3-Feature-selection-amp-Interpretation-with-SHAP" class="headerlink" title="3. Feature selection &amp; Interpretation with SHAP"></a>3. Feature selection &amp; Interpretation with SHAP</h4><p>Because the rock-machine interaction parameters generated during TBM excavation have very clear physical meanings, these data are all understood in the field of civil engineering, and our instructor is from the School of Civil Engineering. Therefore, instead of directly using traditional machine learning, he is more inclined to adopt an interpretable method, because it can combine machine learning with existing civil engineering knowledge. Therefore, I found SHAP, which can visually display the importance of features and the impact of feature size on the prediction results of machine learning models (for example: when feature A is greater than 5, the model is more inclined to classify a certain point into the first category ; When the feature A is less than 5, the model is more inclined to classify a certain point into the second category). Therefore, I used SHAP and combined the knowledge in the field of civil engineering to initially screen out 20 features.</p><p>After that, I sequentially selected different numbers of features from these 20 features, performed machine learning model training and result evaluation, and finally selected 15 from these 20 features as the final feature.</p><p>The relationship between the features obtained by SHAP and the model results (the larger the SHAP value, the model is more likely to predict 2[collapse], otherwise it tends to predict 0[normal]): </p><p><img src="/images/TBM/TBM4.png" alt="TBM1"></p><p>Feature importance map obtained by SHAP: </p><p><img src="/images/TBM/TBM5.png" alt="TBM1"></p><h4 id="4-Hyperparameter-optimization"><a href="#4-Hyperparameter-optimization" class="headerlink" title="4. Hyperparameter optimization"></a>4. Hyperparameter optimization</h4><p>Hyperparameter optimization in machine learning is very important because it directly determines the result of a model. Because traditional grid search is too slow, I thought of adopting some swarm intelligence optimization algorithms, such as differential evolution algorithm, genetic algorithm, particle swarm algorithm, simulated annealing algorithm, ant colony algorithm, immune optimization algorithm, fish school algorithm and so on.</p><p>After a series of experiments, I found that particle swarm optimization (PSO) is the most suitable for our project. However, although the traditional PSO is better than the others in terms of convergence speed and accuracy, the good is not obvious, so I started to improve the PSO.</p><p>I improved the PSO based on the PSO source code in the open source library scikit-opt (<a href="https://scikit-opt.github.io/scikit-opt/#/docs/en">https://scikit-opt.github.io/scikit-opt/#/docs/en</a>), and improved two versions.</p><h4 id="5-Model-training"><a href="#5-Model-training" class="headerlink" title="5. Model training"></a>5. Model training</h4><p>The advance prediction of landslide is essentially a 3-classification problem (normal-0, warning-1, landslide-2). We tried many machine learning models, logistic regression, SVM, random forest, etc., and compared a series of evaluation indicators such as recall rate, and finally chose lightGBM for prediction. In the end, our prediction accuracy is not bad, with recall reaching about 0.7, as shown in the figure below.</p><img src="../images/TBM/TBM6.png" alt="TBM1" style="zoom:88%;" /><h4 id="6-Use-pyqt-to-develop-Windows-desktop-applications"><a href="#6-Use-pyqt-to-develop-Windows-desktop-applications" class="headerlink" title="6. Use pyqt to develop Windows desktop applications"></a>6. Use pyqt to develop Windows desktop applications</h4><p>Use pyqt to complete the development of desktop applications and realize the functions of three modules: collapse warning, fault warning, and real-time prediction of rock-machine interaction parameters. Below are some screenshots.</p><p><strong>Data preprocessing:</strong> </p><p><img src="/images/TBM/TBM7.png" alt="TBM1"></p><p><strong>Normal period:</strong> </p><p><img src="/images/TBM/TBM8.png" alt="TBM1"></p><p><strong>Warning period:</strong></p><p><img src="/images/TBM/TBM9.png" alt="TBM1"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/TBM/TBM1.png&quot; alt=&quot;TBM1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="Python" scheme="http://blog.andy.fit/tags/Python/"/>
    
    <category term="Machine Learning" scheme="http://blog.andy.fit/tags/Machine-Learning/"/>
    
    <category term="PSO" scheme="http://blog.andy.fit/tags/PSO/"/>
    
    <category term="SHAP" scheme="http://blog.andy.fit/tags/SHAP/"/>
    
    <category term="PyQt" scheme="http://blog.andy.fit/tags/PyQt/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="http://blog.andy.fit/2021/11/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <id>http://blog.andy.fit/2021/11/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</id>
    <published>2021-11-08T12:27:56.000Z</published>
    <updated>2021-11-15T05:25:09.227Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><h3 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h3&gt;&lt;h3 id=&quot;第二章&quot;&gt;&lt;a href=&quot;#第二章&quot; class=&quot;headerlink&quot; title=&quot;第二章&quot;&gt;&lt;/a&gt;第二章&lt;/h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://blog.andy.fit/2021/11/08/hello-world/"/>
    <id>http://blog.andy.fit/2021/11/08/hello-world/</id>
    <published>2021-11-08T12:19:41.723Z</published>
    <updated>1985-10-26T08:15:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
